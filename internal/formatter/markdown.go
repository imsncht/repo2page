package formatter

import (
	"fmt"
	"strings"
	"time"

	"github.com/imsncht/repo2page/internal/core"
)

// RenderMarkdown renders the repository into a Markdown document.
func RenderMarkdown(
	repoName string,
	source string,
	tree string,
	files []core.RenderedFile,
	stats core.Statistics,
	warnings []string,
) string {

	var b strings.Builder

	// Header
	b.WriteString(fmt.Sprintf("# Repository: %s\n\n", escapeMarkdown(repoName)))
	b.WriteString(fmt.Sprintf("**Source:** %s  \n", escapeMarkdown(source)))
	b.WriteString(fmt.Sprintf("**Generated:** %s  \n", time.Now().UTC().Format(time.RFC3339)))
	b.WriteString(fmt.Sprintf(
		"**Files:** %d | **Lines:** %d | **Size:** %d KB\n\n",
		stats.FileCount,
		stats.TotalLines,
		stats.TotalSizeKB,
	))

	// Directory Tree
	if tree != "" {
		b.WriteString("## Directory Structure\n\n")
		b.WriteString("```text\n")
		b.WriteString(tree)
		if !strings.HasSuffix(tree, "\n") {
			b.WriteString("\n")
		}
		b.WriteString("```\n\n")
	}

	// Files
	b.WriteString("## Files\n\n")

	for _, file := range files {
		b.WriteString(fmt.Sprintf("### %s\n\n", escapeMarkdown(file.Path)))

		lang := detectLanguage(file.Path)
		if lang != "" {
			b.WriteString(fmt.Sprintf("```%s\n", lang))
		} else {
			b.WriteString("```\n")
		}

		b.WriteString(file.Content)
		if !strings.HasSuffix(file.Content, "\n") {
			b.WriteString("\n")
		}
		b.WriteString("```\n\n")
	}

	// Warnings
	if len(warnings) > 0 {
		b.WriteString("## Warnings\n\n")
		for _, w := range warnings {
			b.WriteString(fmt.Sprintf("- %s\n", escapeMarkdown(w)))
		}
		b.WriteString("\n")
	}

	// Footer
	b.WriteString("---\n")
	b.WriteString("Generated by **repo2page**\n")

	return b.String()
}

// --------------------
// Helpers
// --------------------

func escapeMarkdown(s string) string {
	replacer := strings.NewReplacer(
		"`", "\\`",
		"*", "\\*",
		"_", "\\_",
		"[", "\\[",
		"]", "\\]",
	)
	return replacer.Replace(s)
}

func detectLanguage(path string) string {
	ext := ""
	if i := strings.LastIndex(path, "."); i != -1 {
		ext = path[i+1:]
	}

	switch strings.ToLower(ext) {
	case "go":
		return "go"
	case "js":
		return "javascript"
	case "ts":
		return "typescript"
	case "py":
		return "python"
	case "java":
		return "java"
	case "c":
		return "c"
	case "cpp", "cc", "cxx":
		return "cpp"
	case "rs":
		return "rust"
	case "sh":
		return "bash"
	case "yaml", "yml":
		return "yaml"
	case "json":
		return "json"
	case "html":
		return "html"
	case "css":
		return "css"
	case "md":
		return "markdown"
	case "sql":
		return "sql"
	case "php":
		return "php"
	case "swift":
		return "swift"
	case "kt":
		return "kotlin"
	case "rb":
		return "ruby"
	default:
		return ""
	}
}
